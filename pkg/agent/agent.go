package agent

import (
	"crypto/rsa"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net"
	"net/http"
	"path"
	"strings"
	"time"

	"github.com/Xide/rssh/pkg/api"
	"github.com/Xide/rssh/pkg/utils"

	"github.com/rs/zerolog/log"
	"golang.org/x/crypto/ssh"
)

// ForwardedHost describe a socket exposed by the agent
// through the gatekeeper.
type ForwardedHost struct {
	// complete FQDN for which the host is bound
	Domain string `json:"domain" mapstructure:"domain"`
	// Address or domain on which the agent will dial the connection
	Host string `json:"host" mapstructure:"host"`
	// Port on which the agent will connect to
	Port uint16 `json:"port" mapstructure:"ports"`
	// UUID assigned to the agent
	UID string

	privateKey     *rsa.PrivateKey
	gatekeeperPort uint16
}

// Agent is the main structure of this package, it gets deserialized from
// the configuration file.
type Agent struct {
	// Auto generated by `Agent.synchronizeIdentities` from the filesystem
	hosts []ForwardedHost
	// Currently bound channels
	actives []ForwardedHost
	// Persistent agent configuration directory
	RootDirectory string `json:"root_directory" mapstructure:"root_directory"`
	// Port on which the API listen to requests on the root domain
	APIPort uint16 `json:"api_port" mapstructure:"api_port"`
}

func publicKeyFile(file string) ssh.AuthMethod {
	buffer, err := ioutil.ReadFile(file)
	if err != nil {
		return nil
	}

	key, err := ssh.ParsePrivateKey(buffer)
	if err != nil {
		return nil
	}
	return ssh.PublicKeys(key)
}

func forwardConnection(conn ssh.Channel, fwd *ForwardedHost) error {
	localHost := fmt.Sprintf("%s:%d", fwd.Host, fwd.Port)
	localConn, err := net.Dial("tcp", localHost)
	if err != nil {
		return err
	}
	go func() {
		defer conn.Close()
		defer localConn.Close()
		io.Copy(conn, localConn)
	}()
	go func() {
		defer conn.Close()
		defer localConn.Close()
		io.Copy(localConn, conn)
	}()
	return nil
}

func (a *Agent) handleNewConnections(ch <-chan ssh.NewChannel, fwHost *ForwardedHost) {
	for {
		select {
		case x := <-ch:
			if x == nil {
				log.Warn().
					Str("domain", fwHost.Domain).
					Msg("Connection to gatekeeper interrupted")
				// Removes fwHost from the list of active connections.
				for idx, h := range a.actives {
					if h.UID == fwHost.UID {
						a.actives = append(a.actives[:idx], a.actives[idx+1:]...)
					}
				}
				return
			}
			log.Debug().
				Str("domain", fwHost.Domain).
				Msg("New connection request.")
			ch, _, err := x.Accept()
			if err != nil {
				log.Warn().
					Str("error", err.Error()).
					Str("domain", fwHost.Domain).
					Msg("Failed to accept new connection.")
			}
			err = forwardConnection(ch, fwHost)
			if err != nil {
				log.Warn().
					Str("error", err.Error()).
					Str("domain", fwHost.Domain).
					Msg("Failed to forward new connection.")
			}

		}
	}
}

func (a *Agent) establishReverseForward(host string, port uint16, slot uint16, fwHost *ForwardedHost) error {
	pubKeyFile := path.Join(
		a.RootDirectory,
		"identities",
		fmt.Sprintf("id_rsa.%s.pub", fwHost.Domain),
	)

	sshConfig := &ssh.ClientConfig{
		User: "rssh_agent",
		Auth: []ssh.AuthMethod{
			publicKeyFile(pubKeyFile),
		},
		HostKeyCallback: ssh.InsecureIgnoreHostKey(),
	}

	gkAddr := fmt.Sprintf("%s:%d", host, port)
	conn, err := net.Dial("tcp", gkAddr)
	if err != nil {
		return err
	}
	sshConn, ch, _, err := ssh.NewClientConn(conn, gkAddr, sshConfig)
	if err != nil {
		return err
	}

	c, data, err := sshConn.SendRequest("tcpip-forward", true, ssh.Marshal(&struct {
		BindAddr string
		BindPort uint32
	}{
		BindAddr: "0.0.0.0",
		BindPort: uint32(slot),
	}))
	if err != nil {
		return err
	}
	if c {
		cn, err := net.Dial("tcp", fmt.Sprintf("%s:%d", host, uint32(slot)))
		if err != nil {
			sshConn.Close()
			return err
		}
		cn.Close()
		log.Info().
			Str("domain", fwHost.Domain).
			Str("host", fwHost.Host).
			Uint16("port", fwHost.Port).
			Msg("Established forwarding.")
		a.actives = append(a.actives, *fwHost)
		go a.handleNewConnections(ch, fwHost)
	} else {
		log.Error().
			Str("response", string(data)).
			Msg("Failed to request port forwarding.")
		return errors.New(string(data))
	}
	return nil
}

func (a *Agent) discoverGkPort(fwHost *ForwardedHost) (gkPort uint16, slot uint16, err error) {
	subDomain, rootDomain := utils.SplitDomainRequest(fwHost.Domain)

	resp, err := http.Post(
		fmt.Sprintf("http://%s:%d/auth/%s?identity=%s", rootDomain, a.APIPort, subDomain, fwHost.UID),
		"application/json",
		strings.NewReader("{}"),
	)
	if err != nil {
		return 0, 0, err
	}
	defer resp.Body.Close()
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return 0, 0, err
	}

	authResp := api.AuthResponse{}
	err = json.Unmarshal(body, &authResp)
	if err != nil {
		return 0, 0, err
	}
	if authResp.Err != nil {
		return 0, 0, errors.New(authResp.Err.Msg)
	}
	log.Debug().
		Str("gk_infos", fmt.Sprintf("%v", authResp.Infos)).
		Str("uid", fwHost.UID).
		Str("domain", fwHost.Domain).
		Msg("Authenticated.")
	gkPort = authResp.Infos.GkMeta.SSHPort
	slot = authResp.Infos.Port
	return
}

// Init stup the identities and directories required by the agent.
func (a *Agent) Init() error {
	if err := a.setupFileSystem(); err != nil {
		return err
	}
	if err := a.synchronizeIdentities(); err != nil {
		return err
	}
	log.Debug().Msg("Agent initialized")
	return nil
}

// WalkIdentities calls fn() on each of the parsed keys from the filesystem
func (a *Agent) WalkIdentities(fn func(*ForwardedHost)) {
	for _, x := range a.hosts {
		fn(&x)
	}
}

func (a *Agent) isRunning(fwHost *ForwardedHost) bool {
	for _, running := range a.actives {
		if fwHost.UID == running.UID {
			return true
		}
	}
	return false
}

func (a *Agent) reconciliationLoop() {
	for {
		if err := a.synchronizeIdentities(); err != nil {
			log.Error().
				Str("error", err.Error()).
				Msg("Could not synchronize identities.")
		}
		for _, credential := range a.hosts {
			if !a.isRunning(&credential) {
				_, root := utils.SplitDomainRequest(credential.Domain)
				gkPort, slot, err := a.discoverGkPort(&credential)
				if err != nil {
					log.Warn().
						Str("error", err.Error()).
						Str("uid", credential.UID).
						Msg("Failed to authenticate.")
					continue
				}
				err = a.establishReverseForward(root, gkPort, slot, &credential)
				if err != nil {
					log.Warn().
						Str("error", err.Error()).
						Str("uid", credential.UID).
						Msg("Failed to establish reverse forward")
				}
			}
		}

		time.Sleep(5 * time.Second)
	}
}

// Run is the entrypoint for the agent
func (a *Agent) Run() {
	a.Init()
	log.Info().
		Int("hosts_count", len(a.hosts)).
		Msg("Finished hosts import.")
	a.reconciliationLoop()
}
